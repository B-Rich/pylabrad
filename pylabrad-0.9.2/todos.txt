GENERAL:
    framework cleanup:
        add lookup to sendRequest/sendMessage functions in LabradProtocol
        mark methods that can be overridden, should not be overridden, etc.
        templates for servers and clients
        make clear separation between framework and non-framework code (e.g. for servers)
        define interfaces for various components
        functions that handle certain events (e.g. context expiration) are tricky to override
        in subclasses, but I'm not sure exactly how to fix this
    
    server:
        have a separate object that takes a LabRAD server and adapts it to be
        a TCPClient, without having the LabradServer itself _be_ one.  This
        will simplify a lot of the methods.  Also, the TCPClient will handle
        dispatching requests to handlers, rather than having this be the
        responsibility of the LabradServer or the protocol.
        
        add or remove settings and signals dynamically.  This will greatly help
        the API to get this right.  Also dynamically change help text, etc.
    
	signals and slots (multiple dispatch, loose coupling):
        server side:
            setting to sign up for and cancel notifications
        client side:
            "connect" method lets you connect listeners, and handles
            making the actual signup request.  However, if the server then
            disconnects and reconnects, the connection is broken (this would
            be fixed if the Manager had broadcast messages).
        listener API:
            messages coming in have a source, context, and individual message records
            have IDs.  How do these get dispatched to listeners?  Also, how do we specify
            the dispatch mechanism at the time when listeners are added?
		disconnect listeners when a server disconnects
        error handling in signal/slot and messaging mechanisms
    
    use environment variable interpolation in util.run_server
    
    logging:
        allow logs to be accessed and manipulated remotely
		configurable debug/logging verbosity levels (change on the fly)
        servers have flexible self.log method and log signal
    
    testing:
		need to be able to start and stop servers from inside tests
		quantify code converage (how?)
		generate lots of random data (good and mal-formed)
		profiling for data flatten/unflatten operations to test speed
            use this to help optimize flattening/unflattening
		test setting decorator
        test reversible eval and repr of labrad data
        test device model (in particular, locking)
        
    units:
        make unit objects interoperate with numpy arrays transparently
        test unit handling and conversion
        cache unit objects not just by parsed name, but by exponents
    
	contexts:
        access self.client through context so that contexts get
            propagated correctly (this makes cancellation work correctly)
        sign up for and handle request expiration messages
		
    config overrides in places other than labrad.config:
        use configObj
        model config loading on ipython/matplotlib
        per-user, per-session, etc.
    save/load data and configuration:
        save config in registry where possible, but allow local override
        
	request cancellation:
        when a request is cancelled, a message is sent to the server.  This causes the
        server to stop processing that request (throw an error inside the handler, or just
        stop processing additional records)
        
    distribution:
        easy_install
		PyPI: python setup.py register
			http://docs.python.org/dist/postinstallation-script.html
		
    tutorial mode for beginners
    code/API documentation (epydoc, pydoctor/lore, pydoc)
    
SERVERS:
    NODE:
        set logging levels
		node config files:
			set servers to be started on initial login
			set servers to be auto-restarted if they die
			make node configuration accessible/modifiable remotely
            allow to save configuration changes made remotely
		server config files:
			declare dependencies to be auto-started
        make sure refresh server list works (also do remote svn update)
        report info about self:
            version number, labrad version, python version, host, etc.
        

    SUPER NODE:
        ask for a server to be started
            supernode looks up the location to run the server in the registry
            dependencies will get started automatically
            
    CONTROLLER:
        make server output visible (and clearable, etc.) in the browser
        access all node settings remotely (e.g. directories, environment variables)
        run multiple server instances on one node (set environment variables for each, etc.)
        
    CLIENT:
        signal listeners need to be removed if a server disconnects
        separate views of servers in different context
		caching needs to be updated if setting numbers change
        bulletproofing
            make disconnect work cleanly
            make request cancellation work cleanly
        some settings invisible by default (e.g. logging stuff)?
        asynchronous client use dynamic dispatch (tab-completion not needed)


    